# -*- coding: utf-8 -*-
"""calcule_a_derivada.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CKwvnIhHEkhFVfUbDCPC1t4cCBi9RJW8
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation, PillowWriter
from IPython.display import HTML
import warnings

# Sistema de eixos
fig = plt.figure(figsize=(12, 5))
ax = plt.subplot(1, 1, 1)

# Função
f = lambda x: np.sin(x)

# Sequência de pontos
x = np.linspace(0, 10, 50)

# Construir o gráfico
ax.plot(x, f(x))

# Plotar um ponto P1
x1 = np.pi
p1 = (x1, f(x1))
ax.plot(p1[0], p1[1], 'ro')

# Plotar x + h
h = 0.001
x2 = x1 + h
p2 = (x2, f(x2))
ax.plot(p2[0], p2[1], 'go')

# Plotar uma reta secante à esses dois pontos
ax.axline(xy1=p1, xy2=p2, color='purple', linewidth=0.7)

# Sistema de eixos
fig = plt.figure(figsize=(12, 5))
ax = plt.subplot(1,1,1, ylim=(-1.2, 1.2))

# Função
f = lambda x: np.sin(x)

# Sequência de pontos
x = np.linspace(0, 10, 500)

# Calcular o f(x) para cada x da sequência acima
y = f(x)

# Construir o gráfico
ax.plot(x, y, '-')

# Definindo dois pontos vazios, esses pontos vão receber (x, f(x)) e (x+h, f(x+h))
x1 = 2.0
p1 = (x1, f(x1))

h=0.5
x2 = x1 + h
p2 = (x2, f(x2))

pto1, = ax.plot(p1[0], p1[1], 'ro')
pto2, = ax.plot(p2[0], p2[1], 'go')

linha = ax.axline(xy1=p1, xy2=p2, color="purple", linewidth=0.7)

plt.show()

# Função que altera o valor dos pontos
def linha_ab(delta=1, x1=2, pt1=pto1, pt2=pto2):
  x2 = x1 + delta
  y1 = f(x1)
  y2 = f(x2)

  pt1.set_data([x1], [y1])
  pt2.set_data([x2], [y2])

  inclinação = (y2-y1) / delta

  linha.set_data([x1, x2], [f(x1), f(x2)])

  return (pt1, pt2)

linha_ab(delta=2)

# Definir a figura e um sistema de eixos
fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 10))
plt.subplots_adjust(hspace=0)

ax1 = plt.subplot(2, 1, 1)
ax2 = plt.subplot(2, 1, 2)

# Definir a função
f = lambda x: np.sin(x)
flinha = lambda x: np.cos(x)

# Definir uma sequencia uniforme em x para o nosso gráfico
x = np.linspace(0, 10, 500)

# Calcular f(x) para cada x da sequencia acima
y = f(x)

# Construir o gráfico
ax1.plot(x, y, '-');
ax2.plot(x, flinha(x))

# Rótulos dos eixos verticais
ax1.set_ylabel('Sen(x)')
ax2.set_ylabel('Sen´(x) = Cos(x)')

# Plotar (x, f(x)) e (x, f'(x)) nos gráficos (x, f(x)) e (x+h, f(x+h))
h = 0.0001
x1 = 0
x2 = x1 + h

p1, = ax1.plot([x1], [f(x1)], 'ro')
linha = ax1.axline(xy1=[x1, f(x1)], xy2=[x2, f(x2)], color="red", linewidth=0.5)

plinha, = ax2.plot([x1], [flinha(x1)], 'ro')

# Plota linhas verticais de referência em X nos dois gráficos
linhav1 = ax1.axvline(x1, linewidth=0.5, linestyle='--')
linhav2 = ax2.axvline(x1, linewidth=0.5, linestyle='--')

# Essa função altera os dados dos elementos do gráfico para a animação
def linha_ab(delta=0.0001, x1=4.5 ,p1_=p1, p2_=p2, plin=plinha):
# Dado o ponto x, define a derivada para um delta bem pequeno
    x2 = x1 + delta

    # Altera as linhas verticais de acordo com x
    linhav1.set_data([x1, x1], [0,1])
    linhav2.set_data([x1, x1], [0,1])

    # Altera os pontos de referencia de acordo com x
    p1_.set_data([x1], [f(x1)])
    plin.set_data([x1], [flinha(x1)])

    # Calcula a inclinação
    inclinação = (f(x2) - f(x1)) / (x2 - x1)

    # Altera a posição da reta tangente de acordo com x
    linha.set_data([x1, x2], [f(x1), f(x2)])
    return linhav1, linhav2

l = linha_ab(x1=1.75 * np.pi / 2)