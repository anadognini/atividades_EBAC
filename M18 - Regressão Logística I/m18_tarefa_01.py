# -*- coding: utf-8 -*-
"""m18_tarefa_01.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iMPxTV2GrgvXIVLqhYAk8cE7aY4J9H76

# Regressão Logística I
## Tarefa I

Neste exercício vamos trabalhar com a base "Heart Disease Data Set" disponível no site do [UCI](https://archive.ics.uci.edu/ml/datasets/heart+disease).

Temos 303 indivíduos e vamos utilizar 13 variáveis disponíveis para prever a presença de doença cardíaca na variável ```num```(a 14$^a$ variável).

A descrição das variáveis está recortada abaixo:
- age: idade do paciente em anos
- sex: sexo (1 = male; 0 = female)  
- cp: tipo de dor no peito
  - 1: angina típica
  - 2: angina atípica
  - 3: dor não-angina
  - 4: assintomático
- trestbps: pressão sanguínea em repouso (em mm Hg na admissão ao hospital
- chol: colesterol sérico em mg/dl
- fbs: (açúcar no sangue em jejum > 120 mg/dl) (1 = True; 0 = False)
- restecg: resultados eletrocardiográficos em repouso
  - 0: normal
  - 1: tendo anormalidade da onda ST-T (Inversões de onda T e / ou ST com elevação ou depressão de > 0.05 mV)
  - 2: mostrando hipertrofia ventricular esquerda provável ou definitiva pelos critérios de Estes
- thalach: frequência cardíaca máxima alcançada
- exang: angina induzida por exercício(1 = sim; 0 = não)
- oldpeak = Depressão de ST induzida por exercício em relação ao repouso
- slope: Depressão de ST induzida por exercício em relação ao repouso
  - 1: inclinação ascendente
  - 2: estável
  - 3: inclinação descendente
- ca: número de vasos principais (0-3) coloridos por fluorosopia
- thal: 3 = normal; 6 = defeito corrigido; 7 = defeito reversível
- num: diagnóstico de doença cardíaga (status de doença angiográfica)
"""

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np

import statsmodels.formula.api as smf

url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/heart-disease/processed.cleveland.data'

df = pd.read_csv(url,
                 names=['age', 'sex', 'cp', 'trestbps', 'chol', 'fbs', 'restecg',
                        'thalach', 'exang', 'oldpeak', 'slope', 'ca', 'thal', 'num'])
df.head()

df['flag_doente'] = (df['num'] != 0).astype('int64')
df

# 0 é saudável. 1, 2 e 3 são doenças cardíacas

"""1. Monte uma bivariada para a variável ```sex``` com as seguintes estatísticas:

- Número de *saudáveis*
- Número de *doentes*
- Total
- Quantidade média de doentes
- *Odds*
- *Odds ratio* (Use o total como referência)
- Logito (LOG(*Odds*))
- O LOG do *Odds ratio* (com o total como referência) é chamado de *Weight of Evidence* (WOE). Calcule-o.
"""

bivariada_sex = (df
    .groupby('sex')['flag_doente']
    .agg(doentes='sum', total='count')
)

# 1 = saudável, 0 = doente

# Número de saudáveis, número de doentes e total

bivariada_sex['saudaveis'] = bivariada_sex['total'] - bivariada_sex['doentes']
bivariada_sex

# 1 = homem, 0 = mulher

# Quantidade média de doentes
bivariada_sex['media_doentes'] = bivariada_sex['doentes'] / bivariada_sex['total']

# Odds
bivariada_sex['odds'] = bivariada_sex['doentes'] / bivariada_sex['saudaveis']

# Odds total
total_doentes = df['flag_doente'].sum()
total_saudaveis = len(df) - total_doentes
odds_total = total_doentes / total_saudaveis

print(f"Odds total: {odds_total:.2f}")

# Odds ratio (Use o total como referência)
bivariada_sex['odds_ratio'] = bivariada_sex['odds'] / odds_total

# Logito (LOG(Odds))
bivariada_sex['logito'] = np.log(bivariada_sex['odds'])

# Weight of Evidence (WOE)
bivariada_sex['woe'] = np.log(bivariada_sex['odds_ratio'])

bivariada_sex

"""- WOE > 0 → sexo associado a maior risco
- WOE < 0 → sexo associado a menor risco
- WOE ≈ 0 → comportamento semelhante ao total

Observa-se que o sexo masculino apresenta maior odds de doença cardíaca quando comparado ao total da amostra, refletido por um valor positivo de Weight of Evidence.

- WOE feminino: -0.892398;
- WOE masculino: 0.379802.

2. Monte uma bivariada para a variável ```age``` com as seguintes estatísticas:
- Categorize a variável em 5 grupos
- Calcule as mesmas quantidades calculadas no execício anterior
- Calcule também o valor médio da variável ```age```
"""

# Categorizar age em 5 grupos
df['age_cat'] = pd.qcut(df['age'], q=5, duplicates='drop')

bivariada_age = (
    df
    .groupby('age_cat')
    .agg(doentes=('flag_doente', 'sum'), total=('flag_doente', 'count'), media_age=('age', 'mean'))
)

bivariada_age['saudaveis'] = bivariada_age['total'] - bivariada_age['doentes']

# Número de saudáveis, número de doentes e total

bivariada_age

# Quantidade média de doentes
bivariada_age['media_doentes'] = bivariada_age['doentes'] / bivariada_age['total']

# Odds
bivariada_age['odds'] = bivariada_age['doentes'] / bivariada_age['saudaveis']

# Odds total
total_doentes = df['flag_doente'].sum()
total_saudaveis = len(df) - total_doentes

odds_total = total_doentes / total_saudaveis

# Odds ratio (Use o total como referência)
bivariada_age['odds_ratio'] = bivariada_age['odds'] / odds_total

# Logito (LOG(Odds))
bivariada_age['logito'] = np.log(bivariada_age['odds'])

# WOE
bivariada_age['woe'] = np.log(bivariada_age['odds_ratio'])

bivariada_age

"""Observa-se que as faixas etárias mais elevadas apresentam maior média de doentes e valores crescentes de odds e WOE, indicando uma associação positiva entre idade e ocorrência de doença cardíaca.

3. Visualize a informação da bivariada construída acima através de um gráfico da sua escolha.
"""

# Gráfico para sex

plt.figure(figsize=(5, 4))
plt.bar(
    bivariada_sex.index.astype(str),
    bivariada_sex['woe']
)

plt.axhline(0, linestyle='--')
plt.xlabel('Sexo')
plt.ylabel('Weight of Evidence (WOE)')
plt.title('WOE por sexo')
plt.show()

# Gráfico para age

plt.figure(figsize=(8, 5))
plt.plot(
    bivariada_age.index.astype(str),
    bivariada_age['woe'],
    marker='o'
)

plt.axhline(0, linestyle='--')
plt.xlabel('Faixa etária')
plt.ylabel('Weight of Evidence (WOE)')
plt.title('WOE por faixa etária')
plt.xticks(rotation=45)
plt.show()

# Comparando age X sex
bivariada_age_sex = (
    df
    .groupby(['age_cat', 'sex'])
    .agg(doentes=('flag_doente', 'sum'), total=('flag_doente', 'count'))
)

bivariada_age_sex['saudaveis'] = (bivariada_age_sex['total'] - bivariada_age_sex['doentes'])
bivariada_age_sex['odds'] = (bivariada_age_sex['doentes'] / bivariada_age_sex['saudaveis'])
bivariada_age_sex['odds_ratio'] = bivariada_age_sex['odds'] / odds_total
bivariada_age_sex['woe'] = np.log(bivariada_age_sex['odds_ratio'])
bivariada_age_sex = bivariada_age_sex.reset_index()
bivariada_age_sex

plt.figure(figsize=(9, 5))

for sexo in bivariada_age_sex['sex'].unique():
    subset = bivariada_age_sex[bivariada_age_sex['sex'] == sexo]
    plt.plot(
        subset['age_cat'].astype(str),
        subset['woe'],
        marker='o',
        label=f'sex = {sexo}'
    )

plt.axhline(0, linestyle='--')
plt.xlabel('Faixa etária')
plt.ylabel('WOE')
plt.title('WOE por faixa etária, separado por sexo')
plt.xticks(rotation=45)
plt.legend()
plt.show()

"""Considerando a aplicação em regressão logística, os gráficos baseados em Weight of Evidence são os mais adequados, pois expressam diretamente a relação entre as variáveis explicativas e o logito da probabilidade do evento. Foram utilizados gráficos de barras para a variável binária sexo, gráfico de linha para a variável idade categorizada e um gráfico combinado para avaliar possíveis interações entre idade e sexo."""