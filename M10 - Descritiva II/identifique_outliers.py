# -*- coding: utf-8 -*-
"""identifique_outliers.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fvnuov5wrk_0KvMuj3tJmm8GFS2Mlwr5
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Fixing random state of reproductability
np.random.seed(2360873)
N = 100

N = 50
x = 0 + 8 * np.random.rand(N)
y = -1 * x + np.random.randn(N) * .4
df8 = pd.DataFrame({'x': x, 'y': y})

_ = sns.regplot(x='x', y='y', data=df8)
df8.corr()

df8.iloc[10, 0] = 10
df8.iloc[10, 1] = 15

_ = sns.regplot(x='x', y='y', data=df8)
plt.xlim(-.5, 10.5)
plt.ylim(-10, 17)
df8.corr()

"""### Remove outlier"""

# Estamos substituindo o valor de x e y do outlier por valores "missing" ou
# nan

x[10] = np.nan
y[10] = np.nan

_ = sns.regplot(x=x, y=y)
np.corrcoef(x, y)[1, 0]

"""### Técnica robusta (rankings)

O exemplo abaixo possui a variável y assimétrica (com valores altos sendo observados mais longe da média). Um método comum como o do boxplot indicaria diversos outliers. Podemos utilizar os rankings para avaliar a associação de forma robusta, ou seja, sem que os outliers tenham grande impacto sobre a análise.
"""

N = 500
x = 0 + 8 * np.random.rand(N)
y = np.exp(.5 * x + np.random.randn(N) * .5)
df4 = pd.DataFrame({'x': x, 'y': y})

_ = sns.regplot(x='x', y='y', data=df4)
df4.corr()

df4_rank = pd.concat([df4, df4.rank()], axis=1)
df4_rank.columns = ['x', 'y', 'x_rank', 'y_rank']

df4_rank

_ = sns.regplot(x='x_rank', y='y_rank', data=df4_rank)

df4_rank.corr()

"""### Logaritmo

| Tempo | Número de bactérias | *log2* (número) |
| --- | --- | --- |
| 1 | 1  | 0 |
| 2 | 2 | 1 |
| 3 | 4 | 2 |
| 4 | 8 | 3 |
| 5 | 16 | 4 |
| 6 | 32 | 5 |
"""

df4_log = df4.copy()
df4_log['log_y'] = np.log(df4_log['y'])

_ = sns.regplot(x='x', y='log_y', data=df4_log)

df4_log.corr()