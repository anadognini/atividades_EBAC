# -*- coding: utf-8 -*-
"""m04_tarefa_02.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QYkdIMzTy4XSFDnV8h7J0XIQhY1tNyjQ

## Exercício 1: Vestibular

Considere que a os dados gerados na célula abaixo contêm o número de acertos de 100 alunos em um vestibular para um curso de exatas, divididas pelos respectivos assuntos. Considere que cada assunto possui um número de questões conforme a tabela abaixo:

| assunto | número de questões |
|:---:|:---:|
| Matemática | 24 |
| Português | 18 |
| Geografia | 8 |
| Inglês | 8 |
| História | 8 |
| Física | 12 |
| Química | 12 |

Usando os comandos de operações com DataFrames que você aprendeu na Aula 03, calcule:

1. (operações com escalar) Calcule o percentual de acerto dos alunos por assunto.  
2. (operações entre *DataFrames) Calcule o total de acertos de cada aluno.  
3. Calcule o porcentual geral de cada aluno.  
4. Suponha que a nota de corte para a segunda fase seja 45. Quantos alunos tiveram nota maior que 45?
"""

import pandas as pd
import numpy as np

np.random.seed(42)

# aqui estou dando um nome à coluna de index só pra podermos visualizar
# melhor o dataframe

index_name = "Id_aluno"

# Adicionei o parâmetro "index" que cria um objeto de índice para o DataFrame
# usando a classe pd.Index Index é uma classe fornecida pelo Pandas para criar
# índices.

# name=index_name: Aqui, estamos definindo o nome do índice usando o valor da
# variável index_name que foi definida anteriormente. Isso atribuirá um nome à
# coluna de índice no DataFrame.

# Com data=range(100) estamos fornecendo os dados para o índice de 0 a 100

df_mat = pd.DataFrame(np.random.randint(24, size=(100, 1)), columns=['Qt_acertos'], index=pd.Index(name=index_name, data=range(100))) # 24
df_por = pd.DataFrame(np.random.randint(18, size=(100, 1)), columns=['Qt_acertos'], index=pd.Index(name=index_name, data=range(100))) # 18
df_geo = pd.DataFrame(np.random.randint(8, size=(100, 1)), columns=['Qt_acertos'], index=pd.Index(name=index_name, data=range(100))) # 8
df_ing = pd.DataFrame(np.random.randint(8, size=(100, 1)), columns=['Qt_acertos'], index=pd.Index(name=index_name, data=range(100))) # 8
df_his = pd.DataFrame(np.random.randint(8, size=(100, 1)), columns=['Qt_acertos'], index=pd.Index(name=index_name, data=range(100))) # 8
df_fis = pd.DataFrame(np.random.randint(12, size=(100, 1)), columns=['Qt_acertos'], index=pd.Index(name=index_name, data=range(100))) # 12
df_qui = pd.DataFrame(np.random.randint(12, size=(100, 1)), columns=['Qt_acertos'], index=pd.Index(name=index_name, data=range(100))) # 12

# 1) Calcule o percentual de acerto dos alunos por assunto.

# Matemática

# Seu código aqui
# imprimindo o dataframe com a quantidade de acertos de cada aluno só para vias de comparação

df_mat

# 1) Calcule o percentual de acerto dos alunos por assunto.

# Matemática

# Seu código aqui

# para calcular a porcentagem de acerto de cada aluno, basta fazer a proporção
# da quantidade de acertos de cada um pelo número de total de questões (24)
# ao realizarmos a divisão do dataframe por um escalar, estamos divindo
# cada elemento do dataframe pelo escalar

acertos_mat = df_mat / 24

acertos_mat

# 1) Calcule o percentual de acerto dos alunos por assunto.

# Português

# Seu código aqui

# imprimindo o dataframe com a quantidade de acertos de cada aluno só para vias de comparação

df_por

# 1) Calcule o percentual de acerto dos alunos por assunto.

# Português

# Seu código aqui

# para calcular a porcentagem de acerto de cada aluno, basta fazer a proporção
# da quantidade de acertos de cada um pelo número de total de questões (18)
# ao realizarmos a divisão do dataframe por um escalar, estamos divindo
# cada elemento do dataframe pelo escalar

acertos_por = df_por / 18

acertos_por

# 1) Calcule o percentual de acerto dos alunos por assunto.

# Geografia

# Seu código aqui

# imprimindo o dataframe com a quantidade de acertos de cada aluno só para vias de comparação

df_geo

# 1) Calcule o percentual de acerto dos alunos por assunto.

# Geografia

# Seu código aqui

# para calcular a porcentagem de acerto de cada aluno, basta fazer a proporção
# da quantidade de acertos de cada um pelo número de total de questões (8)
# ao realizarmos a divisão do dataframe por um escalar, estamos divindo
# cada elemento do dataframe pelo escalar

acertos_geo = df_geo / 8

acertos_geo

# 1) Calcule o percentual de acerto dos alunos por assunto.

# Inglês

# Seu código aqui

# imprimindo o dataframe com a quantidade de acertos de cada aluno só para vias de comparação

df_ing

# 1) Calcule o percentual de acerto dos alunos por assunto.

# Inglês

# Seu código aqui

# para calcular a porcentagem de acerto de cada aluno, basta fazer a proporção
# da quantidade de acertos de cada um pelo número de total de questões (8)
# ao realizarmos a divisão do dataframe por um escalar, estamos divindo
# cada elemento do dataframe pelo escalar

acertos_ing = df_ing / 8

acertos_ing

# 1)  Calcule o percentual de acerto dos alunos por assunto.

# História

# Seu código aqui

# imprimindo o dataframe com a quantidade de acertos de cada aluno só para vias de comparação

df_his

# 1)  Calcule o percentual de acerto dos alunos por assunto.

# História

#Seu código aqui

# para calcular a porcentagem de acerto de cada aluno, basta fazer a proporção
# da quantidade de acertos de cada um pelo número de total de questões (8)
# ao realizarmos a divisão do dataframe por um escalar, estamos divindo
# cada elemento do dataframe pelo escalar

acertos_his = df_his / 8

acertos_his

# 1)  Calcule o percentual de acerto dos alunos por assunto.

# Física

# Seu código aqui

# imprimindo o dataframe com a quantidade de acertos de cada aluno só para vias de comparação

df_fis

# 1) Calcule o percentual de acerto dos alunos por assunto.

# Física

# Seu código aqui

# para calcular a porcentagem de acerto de cada aluno, basta fazer a proporção
# da quantidade de acertos de cada um pelo número de total de questões (12)
# ao realizarmos a divisão do dataframe por um escalar, estamos divindo
# cada elemento do dataframe pelo escalar

acertos_fis = df_fis / 12

acertos_fis

# 1)  Calcule o percentual de acerto dos alunos por assunto.

# Química

# Seu código aqui

# imprimindo o dataframe com a quantidade de acertos de cada aluno só para vias de comparação

df_qui

# 1) Calcule o percentual de acerto dos alunos por assunto.

# Química

# Seu código aqui

# para calcular a porcentagem de acerto de cada aluno, basta fazer a proporção
# da quantidade de acertos de cada um pelo número de total de questões (12)
# ao realizarmos a divisão do dataframe por um escalar, estamos divindo
# cada elemento do dataframe pelo escalar

acertos_qui = df_qui / 12

acertos_qui

# 2) Calcule o total de acertos de cada aluno.

# Seu código aqui

# se os dataframes instanciados no começo (df_mat, df_port, etc.) representam
# a quantidade de acertos de cada aluno por disciplina, então basta somar
# todos os dataframes. O que vai acontecer é que estaremos somando os valores
# dos acertos de cada aluno

acertos_aluno = df_mat + df_por + df_geo + df_ing + df_his + df_fis + df_qui

acertos_aluno

# 3) Calcule o porcentual geral de cada aluno.

# Seu código aqui

# assim como fizemos com cada disciplina, faremos com o total de acertos de
# cada aluno. Iremos dividir o total de acertos por aluno pelo total de questões
# realizadas (somando, são 90 questões)

porc_total = acertos_aluno / 90

porc_total

# 4) Suponha que a nota de corte para a segunda fase seja 45. Quantos alunos tiveram nota maior que 45?

# Seu código Aqui

# Criei um filtro com uma condição booleana para verificar quais alunos tinham
# tirado nota acima de 45 e armazenei na variável corte. Isso irá gerar um
# novo dataframe, apenas com aqueles alunos que passaram para a próxima fase

nota_corte = acertos_aluno[acertos_aluno['Qt_acertos'] > 45]

# Se corte é um dataframe e cada linha representa um aluno diferente,
# para saber quantos são os alunos que passaram, basta contar a quantidade de
# linhas desse dataframe

alunos_passados = nota_corte.shape[0]

# imprimindo o resultado

print("A quantidade total de alunos que passaram para a segunda fase é:", alunos_passados)

"""## 2) Vestibular II

Ainda sobre o mesmo banco de dados:

1. Neste vestibular, quem 'zera' em matemática, física ou química está desqualificado. Monte um novo *DataFrame* com os alunos desqualificados por este critério.
2. Quantos são esses alunos?
3. Qual a média desses alunos em história e geografia?
4. Monte um *DataFrame* com os alunos que passaram para a segunda fase. Repare que estes alunos não podem ter sido desqualificados.
"""

# 1) Neste vestibular, quem 'zera' em matemática, física ou química está
# desqualificado. Monte um novo DataFrame com os alunos desqualificados por
# este critério.

# seu código aqui

# criando um filtro que irá selecionar os dataframes de matemática, física
# e química, verificando quais dessas quantidades de acertos foram equivalentes
# a 0

desqualificados = acertos_aluno[(df_mat['Qt_acertos'] == 0) | (df_fis['Qt_acertos'] == 0) | (df_qui['Qt_acertos'] == 0)]

desqualificados

# Quantos são esses alunos?

# utilizando novamente o shape para verificar a quantidade de linhas desse
# dataframe

total_des = desqualificados.shape[0]

print("A quantidade de alunos desqualificados é:", total_des)

# 3) Qual a média desses alunos em história e geografia?

# selecionando apenas as linhas dos alunos desqualificados em história e
# geografia com o método locque permite realizar uma seleção pelo nome

# desqualificados.index é usado para selecionar as linhas correspondentes aos
# alunos desqualificados dentre as pontuações do dataframe df_his.
# Assim, estamos pegando as pontuações de história
# apenas para os alunos desqualificados.

# A mesma coisa está sendo feita com a disciplina de geografia

desqualificados_his = df_his.loc[desqualificados.index, 'Qt_acertos']
desqualificados_geo = df_geo.loc[desqualificados.index, 'Qt_acertos']

# calcular a média de História e Geografia para os alunos desqualificados com
# a função mean ()

media_historia = desqualificados_his.mean()
media_geografia = desqualificados_geo.mean()

# imprimindo os resultados

print("Média em História para alunos desqualificados:", media_historia)
print("Média em Geografia para alunos desqualificados:", media_geografia)

"""## 3) Vacinações no Acre
Vamos trabalhar agora com a base de vacinações no Acre. Para facilitar a sua vida, copiamos o link do arquivo na célula abaixo.

1. Quantas vacinas estão registradas nessa base?  
2. Quantos pacientes foram vacinados? (considere um paciente para cada valor único de ```paciente_id```)  
3. Quantos pacientes únicos tomaram a primeira dose? OBS: Há um caractere especial neste campo. Receba os valores do campo com o método ```.unique()```.   
4. Quantos pacientes com menos de 18 anos foram vacinados?  
5. Quantos estabelecimentos aplicaram vacina no Acre?


**OBS:** O portal do DATASUS pode apresentar instabilidades, retornando um erro na segunda célula abaixo. Por este motivo está disponível uma base estática, que se for baixada para o seu *working directory* pode ser lida com este comando: ```df = pd.read_csv('registros de vacinacao covid ACRE.csv', sep=';')```.

**OBS2:** Para saber qual é o seu working directory, rode no jupyter: ```!pwd```.
"""

arquivo = 'https://s3.sa-east-1.amazonaws.com/ckan.saude.gov.br/SIPNI/COVID/uf/uf%3DAC/part-00000-48f9def3-382f-4a5f-92bc-0eb481257ed6.c000.csv'

# 1) Quantas vacinas estão registradas nessa base?

# Sua solução aqui

df = pd.read_csv(arquivo, sep=';')

# 1) Quantas vacinas estão registradas nessa base?

# se cada linha representa um registr de vacinação diferente para esse
# dataframe, então basta contar o número de linhas dele para saber quantas
# vacinas foram registradas

df.shape[0]

# 2) Quantos pacientes foram vacinados? (considere um paciente para cada valor
# único de paciente_id)

# o método nunique() retorna a contagem de valores únicos no dataframe

pacientes_vacinados = df['paciente_id'].nunique()

print("Foram vacinados", pacientes_vacinados, "pacientes")

# 3) Quantos pacientes únicos tomaram a primeira dose? OBS: Há um caractere
# especial neste campo. Receba os valores do campo com o método .unique().

# Solução alternativa:

# inicialmente, eu havia selecionado a primeira_dose através do índice (que é
# o 3º como mostra a lista abaixo), porém, verifiquei que houve uma mudança
# nesses índices ao longo do tempo. Antes, o índice correspondente à primeira
# dose era [0], agora é outro

# array(['Revacinação', '2º Reforço', 'Reforço', '1ª Dose', '2ª Dose',
#       'Dose Adicional', 'Dose', '3º Reforço', '3ª Dose Revacinação',
#      '1ª Dose Revacinação', '1º Reforço', '3ª Dose',
#       '2ª Dose Revacinação', '4ª Dose Revacinação',
#       '5ª Dose Revacinação'], dtype=object)

# A solução alternativa que encontrei seria declarar a 1ª dose como uma variável
# em formato string, visto que é assim que ela está presente na tabela,
# conforme está escrito na tabela, para evitar que ocorram erros provindos da
# alteração da ordem dos índices

# primeira_dose = "1ª Dose"

primeira_dose = df['vacina_descricao_dose'].unique()[3]

df_primeira_dose = df[df['vacina_descricao_dose'] == primeira_dose]

df_primeira_dose['paciente_id'].nunique()

# 4) Quantos pacientes com menos de 18 anos foram vacinados?

# foi filtrada a coluna que indica as idades dos pacientes, selecionando apenas
# aqueles pacientes que são menores de 18 anos

menor_idade = df[df["paciente_idade"] < 18]

menor_idade['paciente_id'].nunique()

# 5) Quantos estabelecimentos aplicaram vacina no Acre?

# A razão social é usada para fins formais, como contratos, acordos legais,
# registros fiscais e transações governamentais. E pode ser única para cada
# empresa e ajuda a identificá-la de maneira exclusiva no mercado, enquanto
# o  é mais flexível e pode ser alterado com mais facilidade, desde que siga
# as regulamentações aplicáveis.

# df['estalecimento_noFantasia'].nunique()

df['estabelecimento_razaoSocial'].nunique()

"""## 4) Vacinação II
Gere um *DataFrame* que contenha somente os estabelecimentos que aplicaram vacinas a menores de 18 anos. Nesse *DataFrame* devem conter somente os dados dos estabelecimentos, mais uma coluna sendo a quantidade de vacinas que o estabelecimento aplicou a menores de 18 anos.  
  
1. crie uma cópia do *DataFrame* original, contendo somente os registros de vacinas realizadas a menores de 18 anos.  
2. crie uma lista das colunas desse *DataFrame* com o atributo de *DataFrame* **.columns()**  
3. Nesse *DataFrame* faça uma contagem do campo ```vacina_categoria_nome```.
3. a partir da lista de colunas, escolha somente aquelas que são referentes ao estabelecimento, faça uma lista com esses valores.  
4. usando o método *.loc*, selecione somente essas variáveis  
5. Aplique o método **.drop_duplicates** e crie uma lista com uma linha para cada estabelecimento, com os dados do estabelecimento  
"""

# 1) Crie uma cópia do DataFrame original, contendo somente os registros de
# vacinas realizadas a menores de 18 anos.

# utilizei o método copy() para realizar a cópia do dataframe que já havia sido
# criado anteriormente

menor_idade.copy()

# 2) crie uma lista das colunas desse DataFrame com o atributo de DataFrame
# .columns

# utilizei o atributo columns e converti as colunas em uma lista, para ficar
# melhor de visualizar

list(menor_idade.columns)

# 3) Nesse DataFrame faça uma contagem do campo vacina_categoria_nome.

# o método value_counts() fornece a contagem de ocorrências de cada valor único
# nesse campo

menor_idade['vacina_categoria_nome'].value_counts()

# 4) A partir da lista de colunas, escolha somente aquelas que são referentes
# ao estabelecimento, faça uma lista com esses valores.
# Usando o método .loc, selecione somente essas variáveis

# selecionando da lista de colunas apenas aquelas relacionadas a estabelecimento

lista_variaveis = ['estabelecimento_valor',
 'estabelecimento_razaoSocial',
 'estalecimento_noFantasia',
 'estabelecimento_municipio_codigo',
 'estabelecimento_municipio_nome',
 'estabelecimento_uf']

#  : após o .loc indica que você está selecionando todas as linhas
# lista_variaveis especifica as colunas que você deseja manter no dataframe
# resultante df_menor_lista.

df_menor_lista = menor_idade.loc[:, lista_variaveis]
df_menor_lista

# 5) Aplique o método .drop_duplicates e crie uma lista com uma linha para cada
# estabelecimento, com os dados do estabelecimento

# aplicando o método drop_duplicates para remover duplicatas com base nas
# colunas de estabelecimento

df_estabelecimentos_unicos = df_menor_lista.drop_duplicates(subset=['estabelecimento_razaoSocial',
                                                                    'estalecimento_noFantasia',
                                                                    'estabelecimento_municipio_codigo',
                                                                    'estabelecimento_municipio_nome',
                                                                    'estabelecimento_uf'])

# criando uma lista com as linhas para cada estabelecimento

lista_estabelecimentos = df_estabelecimentos_unicos.values.tolist()

# imprimindo a lista de estabelecimentos

for estabelecimento in lista_estabelecimentos:
    print(estabelecimento)