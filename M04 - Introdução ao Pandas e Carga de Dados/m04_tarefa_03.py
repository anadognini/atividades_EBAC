# -*- coding: utf-8 -*-
"""m04_tarefa_03.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rDTVdZQf4GlWnR2SfAptPA6RBkvngb8d

# Tarefa 03

- Leia os enunciados com atenção
- Saiba que pode haver mais de uma resposta correta
- Insira novas células de código sempre que achar necessário
- Em caso de dúvidas, procure os Tutores
- Divirta-se :)
"""

import pandas as pd
import requests

"""####  1) Lendo de APIs
Vimos em aula como carregar dados públicos do governo através de um API (*Application Programming Interface*). No exemplo de aula, baixamos os dados de pedidos de verificação de limites (PVL) realizados por estados, e selecionamos apenas aqueles referentes ao estado de São Paulo.

1. Repita os mesmos passos feitos em aula, mas selecione os PVLs realizados por municípios no estado do Rio de Janeiro.
2. Quais são os três *status* das solicitações mais frequentes na base? Quais são suas frequências?
3. Construa uma nova variável que contenha o ano do **status**. Observe que ```data_status``` vem como tipo *object* no **DataFrame**. Dica: você pode usar o método ```.str``` para transformar o tipo da variável em string, em seguida um método como [**slice()**](https://pandas.pydata.org/docs/reference/api/pandas.Series.str.slice.html) ou [**split()**](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.str.split.html).
4. Indique a frequência de cada ano do campo construído no item (3).
"""

# 1)

# Seguindo os passos realizados em sala de aula, estou svando o link de acesso da base de dados em variável
# chamada "url"

url = 'https://apidatalake.tesouro.gov.br/ords/sadipem/tt/pvl?uf=RJ&tipo_interessado=Munic%C3%ADpio'

# Em seguida, estou utilizando o método get() do requests, que faz uma requisição que irá solicitar dados do servidor,
# passando a url salva na variável como parâmetro

r = requests.get(url)

# Em seguida, estou utilizando o atributo status_code para verificar o status da requisição

r.status_code

# 1)

# Para recuperar os dados do objeto de resposta da nossa requisição, precisamos converter o conteúdo
# bruto dela em uma estrutura de dados do tipo json. Isso é feito usando o método json()

data_json = r.json()

# 1)

# Por último, transformei o json em um dataframe e imprimi as cinco primeiras linhas do dataframe
# através do método head()

dataframe_json = pd.DataFrame(data_json['items'])

dataframe_json.head()

# 2)

# No código abaixo, estou chamando utilizando o atributo "status", que representa a coluna de mesmo nome,
# através da notação ponto. Em seguida, estou utilizando o método value_counts() para fazer a contagem da
# frequência com que cada status aparece na base de dados. Os em maior quantidade aparecerão primeiro na lista
# enquanto os em menor quantidade vão aparecer por último

dataframe_json.status.value_counts()

# Os três status mais comuns nessa base de dados são:
# - Deferido (com 98 casos)
# - Arquivado (com 53 casos)
# - Regularizado (com 26 casos)

# 3)

# Utilizei as dicas dadas no enunciado. Primeiro transformei a coluna "data_status" em string através do método str()
# e salvei numa variável chamada data_status_str

# Em seguida, apliquei o split a essa variável, o que retorna uma lista com todos os caracteres da string

data_status_str = dataframe_json.data_status.str
data_status_str.split()

# Apliquei um loop for através do qual peguei os últimos 4 elementos (ano) de cada data na lista e salvei numa variável
# chamada "ano_status"

for i in data_status_str:
    dataframe_json['ano_status'] = data_status_str[6:10]

# Por fim, imprimi as cinco primeiras linhas do dataframe através do método head()

dataframe_json.head()

# 4)

# Apliquei novamente o método value_counts, dessa vez ao atributo gerado pela nova coluna

dataframe_json.ano_status.value_counts()

"""####  2) Melhorando a interação com o API
Observe dois URLs de consultas diferentes, por exemplo o URL utilizado em aula, e o URL feito no exercício anterior. Compare-os e observe as diferenças.

1. Faça uma função em Python que recebe como argumento o UF da consulta e o tipo de interessado (```'Estado'```ou ```Município```), e que devolve os dados da consulta no formato *DataFrame*.
2. Quantas solicitações para o Estado podem ser consultadas para Minas Gerais com *status* em 'Arquivado por decurso de prazo' estão registradas?
3. Qual é o município da Bahia com mais solicitações deferidas?
4. Salve um arquivo .csv com os dados de solicitações da Bahia, com interessado = 'Estado'
"""

#1)

# Definindo a função de nome "consulta_tesouro" que recebe os parâmetros uf e tipo_interessado
# Após isso, defino a url_base que é o início da URL do endpoint da API do Tesouro Nacional para consultas dos dados

# Após isso, crio um dicionário chamado params que contém os parâmetros da consulta: uf (unidade federativa)
# e tipo_interessado. Quando fazemos uma requisição os parâmetros são anexados à URL como pares de chave e valor
# separados por '&' e geralmente vêm após o caractere de interrogação ?.

# Utilizo o método get() para fazer a requisição, passando a url_base e os parâmetros que serão anexados à ela para o método
# Armazeno a requisição numa variável chamada "r"

# Faço uma verificação cuja condição é que o status da requisição seja 200, caso contrário irá retornar uma mensagem de erro.
# Dentro da verificação if, transformo a requisição num objeto json através do método json(), salvando-o numa variável chamada
# data em seguida transformo a lista de items do json em um dataframe chamado df. Por fim, retorno o df ainda dentro do if

def consulta_tesouro(uf, tipo_interessado):
    url_base = 'https://apidatalake.tesouro.gov.br/ords/sadipem/tt/pvl'

    params = {
        'uf': uf,
        'tipo_interessado': tipo_interessado
    }

    r = requests.get(url_base, params=params)

    if (r.status_code == 200):
        data = r.json()
        df = pd.DataFrame(data['items'])

        return df
    else:
        print("Erro na requisição:", r.status_code)

# Por fim, crio duas variáveis, uma chamada UF que irá receber o uf, e uma chamada tipo_interessado que irá
# receber o tipo interessado (Estado ou Município) e passo essas variáveis como parâmetros ao chamar a função
# Tudo isso é salvo numa variável chamada df_resultado e ao final imprimo as cinco primeiras linhas desse dataframe

uf = 'SC'
tipo_interessado = 'Município'

df_resultado = consulta_tesouro(uf, tipo_interessado)
df_resultado

# 2)

# Criando duas variáveis, uma com o uf desejado (MG de Minas Gerais no caso)e outra com o tipo interessado (Estado,
# nesse caso) e passando elas como parâmetros à função criada anteriormente

uf = 'MG'
tipo_interessado = 'Estado'
df_mg = consulta_tesouro(uf, tipo_interessado)

# Por fim, crio um filtro que irá verificar se o status do pvl é igual a "Arquivado por decurso de prazo", imprimindo a coluna
# "status" junto e utilizando o método value_counts() para imprimir a lista com esses valores

df_mg[df_mg['status'] == "Arquivado por decurso de prazo"]['status'].value_counts()

# O total de status com o valor "Arquivado por decurso de prazo" em Minas Gerais é 1

# 3)

# Criando duas variáveis, uma com o uf desejado (BA de Bahia no caso)e outra com o tipo interessado (Município, nesse caso)
# e passando elas como parâmetros à função criada anteriormente

# Por fim, crio um filtro que irá verificar se o status do pvl é igual a "Deferido", imprimindo o nome dos municípios (pela
# coluna "interessado") e utilizando o método value_counts() para imprimir a lista com esses valores

uf = 'BA'
tipo_interessado = 'Município'
df_ba = consulta_tesouro(uf, tipo_interessado)

df_ba[df_ba['status'] == "Deferido"]['interessado'].value_counts()

# O município da Bahia com maior número de status deferidos é Luís Eduardo Magalhães

# 4)

# Criando duas variáveis, uma com o uf desejado (BA de Bahia no caso)e outra com o tipo interessado (Estado, nesse caso)
# e passando elas como parâmetros à função criada anteriormente e armazenando-o em uma variável chamada df_ba_estado

uf = 'BA'
tipo_interessado = 'Estado'
df_ba_estado = consulta_tesouro(uf, tipo_interessado)

# transformando o dataframe em um csv utilizando o método to_csv e salvando com o nome consulta_tesouro_bahia_estado

df_ba_estado.to_csv('consulta_tesouro_bahia_estado.csv')