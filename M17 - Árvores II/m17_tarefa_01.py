# -*- coding: utf-8 -*-
"""m17_tarefa_01.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15-oHPP-hNswYfUAAwd8u7KkgeMo09YvG

# Árvores II - Tarefa I

Neste exercício vamos trabalhar com a base de dados de identificação de atividade humana com smartphones. Smartphones possuem acelerômetro e giroscópio, que registram dados de aceleração e giro nos eixos X, Y e Z, com frequencia de 50 Hz (ou seja, 50 registros por segundo). Os dados foram agrupados a medidas de 0.3 Hz, calculando-se variáveis derivadas como aceleração mínima, máxima, média etc por eixo no período agrupado de tempo, resultando em 561 variáveis que podem ser lidas nas bases disponíveis.

A base é oriunda de um experimento, em que os indivíduos realizavam uma de seis atividades corriqueiras:
- andando
- subindo escada
- descendo escada
- parado
- sentado
- deitado

O objetivo é classificar a atividade humana com base nos dados do acelerômetro e giroscópio do celular.

### 1. Carregar a base

Sua primeira atividade é carregar a base.

Ela está disponível neste link:
https://archive.ics.uci.edu/ml/datasets/human+activity+recognition+using+smartphones

dados https://archive.ics.uci.edu/ml/machine-learning-databases/00240/  
dataset.names https://archive.ics.uci.edu/ml/machine-learning-databases/00240/UCI%20HAR%20Dataset.names  
UCI HAR Dataset.zip https://archive.ics.uci.edu/ml/machine-learning-databases/00240/UCI%20HAR%20Dataset.zip

Você vai encontrar os seguintes arquivos:

- **features.txt:** contém a lista com os nomes das variáveis
- **features_info.txt:** contém a descrição das variáveis
- **README.txt:** contém uma descrição do estudo e das bases
- **activity_labels:** contém o código da atividade (inteiro entre 1 e 6) e a descrição
- **subject_train.txt:** uma lista indicando que registro pertence a que indivíduo na base de treino
- **X_train.txt:** as *features* (ou variáveis explicativas) da base de testes. Cada linha representa um registro das informações de um indivíduo em um intervalo de tempo de aproximadamente 1/0.3 segundo. As medidas estão em ordem temporal dentro do estudo, e o indivíduo que originou a medida está identificado na base subject_train.txt.
- **y_train.txt:** Possui o mesmo número de linhas que X_test. Contém um número de 1 a 6 indicando a atividade que estava sendo realizada por aquele registro na base de treino.
- **subject_test.txt:** uma lista indicando que registro pertence a que indivíduo na base de teste
- **X_test.txt:** as *features* (ou variáveis explicativas) da base de testes. Cada linha representa um registro das informações de um indivíduo em um intervalo de tempo de aproximadamente 1/0.3 segundo. As medidas estão em ordem temporal dentro do estudo, e o indivíduo que originou a medida está identificado na base subject_test.txt.
- **y_test.txt:** Possui o mesmo número de linhas que X_train. Contém um número de 1 a 6 indicando a atividade que estava sendo realizada por aquele registro na base de teste.

Carregue as bases:

1. Faça o download dos arquivos.

2. Carregue a base ```features.txt``` em uma *Series* (por exemplo usando o comando ```pd.read_csv()```.
"""

import pandas as pd
from sklearn.tree import DecisionTreeClassifier
import numpy as np
import matplotlib.pyplot as plt

features = pd.read_csv('UCI HAR Dataset/features.txt', sep=' ', header=None)
features.head()

"""3. Carregue a base subject_train.txt em uma *Series*"""

subject_train = pd.read_csv('UCI HAR Dataset/subject_train.txt', sep=' ', header=None)
subject_train.head()

"""4. Carregue a base X_train.txt

"""

X_train = pd.read_csv('UCI HAR Dataset/X_train.txt', header=None, delim_whitespace=True)
X_train.head()

# 1. Faça com que as colunas deste *dataframe* tenham os nomes indicados em
# features.txt

X_train.columns = features[1]
X_train.head()

# 2. Sem alterar a ordem dos dataframes, coloque o indicador do indivíduo lido
# em subject_train.txt como uma variável a mais neste dataframe

subject_index = subject_train[0].to_numpy()
X_train['subject'] = subject_index
X_train.head()

# 3. Faça com que este dataframe tenha um índice duplo, composto pela ordem dos
# dados e pelo identificador do indivíduo

index_duplo = X_train.index.to_numpy()
X_train['index'] = index_duplo
X_train.set_index(['index', 'subject'], inplace=True)
X_train.head()

"""5. Com a mesma lógica, carregue a base X_test"""

X_test = pd.read_csv('UCI HAR Dataset/X_test.txt', header=None, delim_whitespace=True)
X_test.head()

# 1. Certifique-se de que tenha os nomes lidos em features.txt

X_test.columns = features[1]
X_test.head()

# 2. Coloque o identificador do sujeito lido em subject_test.txt

subject_test = pd.read_csv('UCI HAR Dataset/subject_test.txt', sep=' ', header=None)
X_test['subject'] = subject_test[0].to_numpy()
X_test.head()

# 3. Defina um índice duplo composto pela ordem do registro e o identificador
# do registro

index_duplo_test = X_test.index.to_numpy()
X_test['index'] = index_duplo_test
X_test.set_index(['index', 'subject'], inplace=True)
X_test.head()

"""6. Salve as bases em arquivos CSV para facilitar a leitura deles na terefa 2 deste módulo"""

X_train.to_csv('X_train.csv')
X_test.to_csv('X_test.csv')

"""7. Considere que esta base é maior que a da aula, tanto em linhas quanto em colunas. Selecione apenas as três primeiras colunas da base ('tBodyAcc-mean()-X', 'tBodyAcc-mean()-Y' e 'tBodyAcc-mean()-Z'), para efeitos desse exercício.

**OBS:** As bases já estão divididas em treino e teste, de modo que não vamos precisar da função ```train_test_split```.
"""

y_train = pd.read_csv('UCI HAR Dataset/y_train.txt', sep=' ', header=None)
y_test = pd.read_csv('UCI HAR Dataset/y_test.txt', sep=' ', header=None)

X_train = X_train.iloc[:, :3]
X_test = X_test.iloc[:, :3]
y_train = y_train[0]
y_test = y_test[0]

"""### 2. Ajustar uma árvore de decisão

2.1 ajuste uma árvore de decisão com número mínimo de observações por folha = 20. Certifique-se de que você esteja utilizando apenas as 3 variáveis indicadas no exercício anterior.
"""

clf = DecisionTreeClassifier(min_samples_leaf=20)
clf.fit(X_train, y_train)

"""2.2 Calcule os ccp_alphas. Como feito em aula, certifique-se de que todos os valores são positivos e selecione apenas valores únicos."""

caminho = DecisionTreeClassifier(random_state=2360873, max_depth=3).cost_complexity_pruning_path(X_train, y_train)
ccp_alphas, impurities = caminho.ccp_alphas, caminho.impurities

"""2.3 Considere que vamos fazer uma árvore para cada valor de ```ccp_alpha```. Para ter um pouco mais de velocidade, crie uma coleção de dados com os ```ccp_alphas```, considerando apenas 1 a cada 5 valores. Dica: utilize o slicing do tipo ```array[::5]``` para isto. Caso se sinta seguro, fique à vontade para utilizar mais valores de ```ccp_alpha```."""

ccp_alphas_reduzidos = ccp_alphas[::5]

"""### 3. Desempenho da árvore por ccp_alpha

3.1: Rode uma árvore para cada ```ccp_alpha```, salvando cada árvore em uma lista
"""

arvores = []

for ccp_alpha in ccp_alphas_reduzidos:
    clf = DecisionTreeClassifier(random_state=2360873, ccp_alpha=ccp_alpha).fit(X_train, y_train)
    arvores.append(clf)

"""3.2: Calcule a acurácia de cada árvore na base de treinamento e de teste"""

train_scores = [clf.score(X_train, y_train) for clf in arvores]
test_scores = [clf.score(X_test, y_test) for clf in arvores]

"""3.3: Monte um gráfico da acurácia em função do ```ccp_alpha``` na base de validação e na base de teste"""

fig, ax = plt.subplots()
ax.set_xlabel('Alpha')
ax.set_ylabel('Accuracy')
ax.set_title('Acurácia X Alpha do conjunto de treino e teste')
ax.plot(ccp_alphas_reduzidos, train_scores, marker='o', label='train', drawstyle='steps-post')
ax.plot(ccp_alphas_reduzidos, test_scores, marker='o', label='test', drawstyle='steps-post')
ax.legend()
plt.show()

"""3.4: Selecione a melhor árvore como sendo aquela que possui melhor acurácia na base de teste"""

ind_melhor_arvore = len(test_scores) - test_scores[::-1].index(max(test_scores)) - 1
melhor_arvore = arvores[ind_melhor_arvore]

"""3.5: Qual a melhor acurácia que se pode obter com estas três variáveis?"""

melhor_arvore.score(X_test, y_test)