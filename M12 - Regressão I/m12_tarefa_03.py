# -*- coding: utf-8 -*-
"""m12_tarefa_03.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1trCF7IkMgTNPXLs5D5CertXNvReOhJGn

# Regressão 01 - tarefa 03 - transformações em X e Y

Carregue os pacotes necessários e a base de gorjetas.
"""

import pandas as pd
import seaborn as sns
from seaborn import load_dataset
import matplotlib.pyplot as plt
import numpy as np
import patsy
import statsmodels.api as sm
import statsmodels.formula.api as smf

tips = sns.load_dataset('tips')
tips['tip_pct'] = tips['tip'] / (tips['total_bill'] - tips['tip'])
tips['net_bill'] = tips['total_bill'] - tips['tip']
tips.head()

"""### I. Modelo no valor da gorjeta

1. Crie a matriz de design (e a matriz y) utilizando o Patsy, para um modelo em ```tip```, explicada por ```sex, smoker, diner e net_bill```.
"""

y, X = patsy.dmatrices('tip ~ sex + smoker + time + net_bill', data=tips, return_type='dataframe')

X

y

"""2. Remova as variáveis não significantes.  """

reg = sm.OLS(y, X).fit()
reg.summary()

# As variáveis com menos importância são "sex" e "time", então vamos tentar
# removê-las da modelagem e ver se isso gera alguma melhoria

y2, X2 = patsy.dmatrices('tip ~ smoker + net_bill', tips, return_type='dataframe')
model2 = sm.OLS(y2, X2).fit()
print(model2.summary())

"""3. Observe o gráfico de resíduos em função de ```net_bill```"""

tips['resid2'] = model2.resid

sns.scatterplot(x='net_bill', y='resid2', data=tips)
plt.axhline(y=0, color='r', linestyle='--')

"""O resíduo mostra um leve padrão (a meu ver, está começando a formar um cone). A variância aumenta em contas altas (heterocedasticidade). Isso sugere que a relação não é perfeitamente linear.

4. Teste transformar ```net_bill``` no log e um polinômio. Escolha o melhor modelo.
"""

y3, X3 = patsy.dmatrices('tip ~ smoker + net_bill + I(net_bill**2)', tips, return_type='dataframe')
model3 = sm.OLS(y3, X3).fit()
print(model3.summary())

tips['resid3'] = model3.resid

sns.scatterplot(x='net_bill', y='resid3', data=tips)
plt.axhline(y=0, color='r', linestyle='--')

"""### II. Modelo no valor do percentual da gorjeta

1. Crie a matriz de design (e a matriz y) utilizando o Patsy, para um modelo no log de ```tip```, explicado por ```sex, smoker, diner e net_bill```.
"""

y, X = patsy.dmatrices('np.log(tip_pct) ~ sex + smoker + time + net_bill', data=tips, return_type='dataframe')
model = sm.OLS(y, X).fit()
print(model.summary())

"""2. Remova as variáveis não significantes."""

# As variáveis "sex", "smoker" e "time" se mostram bastante insignificantes de
# acordo com o p value delas.

y2, X2 = patsy.dmatrices('np.log(tip_pct) ~ net_bill', tips, return_type='dataframe')
model2 = sm.OLS(y2, X2).fit()
print(model2.summary())

"""3. Observe o gráfico de resíduos em função de ```net_bill```"""

tips['resid2'] = model2.resid

sns.scatterplot(x='net_bill', y='resid2', data=tips)
plt.axhline(y=0, color='r', linestyle='--')

"""4. Teste transformar ```net_bill``` no log e um polinômio. Escolha o melhor modelo."""

y3, X3 = patsy.dmatrices('np.log(tip_pct) ~ np.log(net_bill)', tips, return_type='dataframe')
model3 = sm.OLS(y3, X3).fit()
print(model3.summary())

tips['resid3'] = model3.resid

sns.scatterplot(x='net_bill', y='resid3', data=tips)
plt.axhline(y=0, color='r', linestyle='--')

# Polinômio

y4, X4 = patsy.dmatrices('np.log(tip_pct) ~ net_bill + I(net_bill**2)', tips, return_type='dataframe')
model4 = sm.OLS(y4, X4).fit()
print(model4.summary())

tips['resid4'] = model4.resid

sns.scatterplot(x='net_bill', y='resid4', data=tips)
plt.axhline(y=0, color='r', linestyle='--')

"""Com base principalmente no R² dos dois modelos, o primeiro se mostra significativamente melhor, com um R² de 0.293 em comparação com o segundo que possui um R² de 0.260.

5. Do modelo final deste item, calcule o $R^2$ na escala de ```tip``` (sem o log). Compare com o modelo do item 1. Qual tem melhor coeficiente de determinação?
"""

tips['pred_log_tip_pct'] = model4.fittedvalues
tips['pred_tip_pct'] = np.exp(tips['pred_log_tip_pct'])

r = tips[['pred_tip_pct', 'tip_pct']].corr().iloc[0,1]
R2_original = r**2
R2_original

"""Ao retornar à escala original da variável dependente (tip_pct), o R² empírico ficou em torno de 0.173. Quando comparado ao modelo que utiliza `tip` como resposta e apresenta R² 0.236, fica claro que o percentual da gorjeta é menos explicado pelo valor da conta. Assim, o modelo do item 1 possui maior poder preditivo.

### III. Previsão de renda

Vamos trabalhar a base que você vai usar no projeto do final deste ciclo.

Carregue a base ```previsao_de_renda.csv```.

|variavel|descrição|
|-|-|
|data_ref                | Data de referência de coleta das variáveis |
|index                   | Código de identificação do cliente|
|sexo                    | Sexo do cliente|
|posse_de_veiculo        | Indica se o cliente possui veículo|
|posse_de_imovel         | Indica se o cliente possui imóvel|
|qtd_filhos              | Quantidade de filhos do cliente|
|tipo_renda              | Tipo de renda do cliente|
|educacao                | Grau de instrução do cliente|
|estado_civil            | Estado civil do cliente|
|tipo_residencia         | Tipo de residência do cliente (própria, alugada etc)|
|idade                   | Idade do cliente|
|tempo_emprego           | Tempo no emprego atual|
|qt_pessoas_residencia   | Quantidade de pessoas que moram na residência|
|renda                   | Renda em reais|
"""

df = pd.read_csv('/content/previsao_de_renda.csv')

# Removendo colunas irrelevantes

for c in ['Unnamed: 0','index','mau']:
    if c in df.columns:
        df = df.drop(columns=[c])

# Padronizando os tipos das variáveis
df['data_ref'] = pd.to_datetime(df['data_ref'])

for col in ['posse_de_veiculo','posse_de_imovel']:
    if df[col].dtype == object:
        df[col] = df[col].map({'True': True, 'False': False, 'true': True, 'false': False}).fillna(df[col])

df.head()

df_simple = df[['renda','tempo_emprego']].dropna()

"""1. Ajuste um modelo de regressão linear simples para explicar ```renda``` como variável resposta, por ```tempo_emprego``` como variável explicativa. Observe que há muitas observações nessa tabela. Utilize os recursos que achar necessário."""

mod1 = smf.ols('renda ~ tempo_emprego', data=df_simple).fit()
print(mod1.summary())

"""2. Faça uma análise de resíduos. Com os recursos vistos neste módulo, como você melhoraria esta regressão?"""

df_simple['fitted'] = mod1.fittedvalues
df_simple['resid'] = mod1.resid

# Resíduos em função dos valores preditos

sns.scatterplot(x='fitted', y='resid', data=df_simple)
plt.axhline(y=0, color='r', linestyle='--')

# Resíduos em função do tempo_emprego

sns.scatterplot(x=df_simple['tempo_emprego'], y='resid', data=df_simple)
plt.axhline(y=0, color='r', linestyle='--')

"""Possíveis ações para melhorar a aparência dos resíduos:
- Transformar renda (ex.: log(renda)) para reduzir heterocedasticidade e tornar erros mais gaussianos.

- Transformar tempo_emprego (log) ou acrescentar termo polinomial (tempo_emprego**2) para capturar curvatura.

- Remover/tratar outliers.

3. Ajuste um modelo de regressão linear múltipla para explicar ```renda``` (ou uma transformação de ```renda```) de acordo com as demais variáveis.
"""

# Fórmula inicial (com log da renda)
formula = 'np.log(renda) ~ idade + tempo_emprego + qtd_filhos + qt_pessoas_residencia + C(sexo) + C(posse_de_veiculo) + C(posse_de_imovel) + C(tipo_renda) + C(educacao) + C(estado_civil) + C(tipo_residencia)'
reg_mul = smf.ols(formula, data=df).fit()
reg_mul.summary()

y, X = patsy.dmatrices(formula, df, return_type='dataframe')

X

y

"""4. Remova as variáveis não significantes e ajuste novamente o modelo. Interprete os parâmetros"""

# Variáveis que se mostram irrelevantes:
# C(educacao)[T.Pós graduação]
# C(educacao)[T.Secundário]
# C(educacao)[T.Superior incompleto]
# C(tipo_residencia)[T.Com os pais]
# C(tipo_residencia)[T.Estúdio]

df['sexo_M'] = (df['sexo'] == 'M').astype(int)
df['posse_veiculo'] = df['posse_de_veiculo'].astype(int)
df['posse_imovel'] = df['posse_de_imovel'].astype(int)
df['renda_Bolsista'] = (df['tipo_renda'] == 'Bolsista').astype(int)
df['renda_Empresario'] = (df['tipo_renda'] == 'Empresário').astype(int)
df['renda_Pensionista'] = (df['tipo_renda'] == 'Pensionista').astype(int)
df['renda_ServidorPublico'] = (df['tipo_renda'] == 'Servidor público').astype(int)
df['edu_SuperiorCompleto'] = (df['educacao'] == 'Superior completo').astype(int)
df['ec_Separado'] = (df['estado_civil'] == 'Separado').astype(int)
df['ec_Solteiro'] = (df['estado_civil'] == 'Solteiro').astype(int)
df['ec_Uniao'] = (df['estado_civil'] == 'União').astype(int)
df['ec_Viuvo'] = (df['estado_civil'] == 'Viúvo').astype(int)
df['res_Casa'] = (df['tipo_residencia'] == 'Casa').astype(int)
df['res_Comunitario'] = (df['tipo_residencia'] == 'Comunitário').astype(int)
df['res_Governamental'] = (df['tipo_residencia'] == 'Governamental').astype(int)


formula_final = """
renda ~ sexo_M +
          posse_veiculo + posse_imovel +
          renda_Bolsista + renda_Empresario + renda_Pensionista + renda_ServidorPublico +
          edu_SuperiorCompleto +
          ec_Separado + ec_Solteiro + ec_Uniao + ec_Viuvo +
          res_Casa + res_Comunitario + res_Governamental +
          idade + tempo_emprego + qtd_filhos + qt_pessoas_residencia
"""

model_final = smf.ols(formula_final, data=df).fit()
model_final.summary()

"""5. Faça uma análise de resíduos. Avalie a qualidade do ajuste."""

df_d['fitted_final'] = model_final.fittedvalues
df_d['resid_final'] = model_final.resid

sns.scatterplot(x='fitted_final', y='resid_final', data=df_d)
plt.axhline(y=0, color='r', linestyle='--')