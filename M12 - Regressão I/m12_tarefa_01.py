# -*- coding: utf-8 -*-
"""m12_tarefa_01.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bzckxOtq-AKlZeG3dVzC31Fv2gs9lx8y

### 1. Explorando a base de gorjetas

#### a. Na aula, fizemos uma regressão de `tip` explicada por `net_bill`. Carregue os pacotes e a base, crie as variáveis necessárias como na aula e reproduza essa regressão.
"""

# Carregando as bibliotecas necessárias

import pandas as pd
import seaborn as sns
from seaborn import load_dataset
import matplotlib.pyplot as plt
import numpy as np
import statsmodels.formula.api as smf

# Carregando a base e criando as variáveis necessárias

tips = sns.load_dataset('tips')
tips['tip_pct'] = tips['tip'] / (tips['total_bill'] - tips['tip'])
tips['net_bill'] = tips['total_bill'] - tips['tip']
tips.head()

# Reproduzindo a regressão

reg = smf.ols('tip ~ net_bill', data=tips).fit()
reg.summary()

"""O método `reg.summary()` nos fornece um output bem completo do modelo de regressão. Estamos usando o nome `reg` para a variável porque queremos que o Python guarde todos os resultados de nosso modelo de regressão. Trata-se de um objeto do tipo `RegressionLinearResultsWrapper` do statsmodels. Esse objeto vem com uma diversidade de métodos e atributos que armazenam os resultados do modelo e podem ser acessados de forma prática.

Podemos ver que:

- Intercept (é o valor estimado de $\alpha$) = 1.3307;
- net_bill (valor estimado de $\beta$) = 0.0993;

Podemos ver também que esses valores se encontram dentro de um intervalo de confiança, o $\alpha$ de 0.999 e 1.662 e o $\beta$ entre 0.082 e 0.117, pois são valores estimados/aproximados. Isso quer dizer que o verdadeiro valor se encontra em algum ponto dentro desse intervalo de confiança.

####. Reproduza também o gráfico de dispersão dessas duas variáveis.
"""

# Gráfico de dispersão

sns.regplot(y = 'tip', x = 'net_bill', data=tips[tips['tip_pct']<.5])

# Gerando dados para a linha dos 10%
x = np.linspace(0, tips['net_bill'].max(), 100)
y = .1 * x

# Plotando a linha dos 10%
plt.plot(x, y, '-r', label='Linha dos 10%')

# Opções estéticas para explicitar o (0, 0) no gráfico
plt.xlim(left=0)
plt.ylim(bottom=0)

"""### 2. Mudança na perspectiva

#### Agora ajuste um modelo de regressão de `tip_pct` por `net_bill`. Construa o gráfico de dispersão correspondente.
"""

reg = smf.ols('tip_pct ~ net_bill', data=tips).fit()
reg.summary()

# Gráfico de dispersão

sns.regplot(y = 'tip_pct', x = 'net_bill', data=tips[tips['tip_pct']<.5])

x = np.linspace(0, tips['net_bill'].max(), 100)
y = .1 * x

plt.plot(x, y, '-r', label='Linha dos 10%')
plt.xlim(left=0)
plt.ylim(bottom=0)

"""### 3. Compare os dois gráficos e comente (de forma objetiva e sucinta) a relação entre eles e a diferença do ajuste. Podemos comparar diretamente os R²s?

Os dois modelos não têm a mesma variável dependente, então o R² não é comparável diretamente.
- R² do primeiro modelo é 0.333: e relação é forte e positiva (gorjetas maiores em contas maiores). O modelo captura proporcionalidade direta.

  No gráfico, vemos uma reta ascendente, mostrando que, quanto maior a conta, maior a gorjeta. A linha vermelha (10%) serve como referência, indicando que muitos clientes deixam algo próximo disso como gorjeta.

- R² do segundo modelo é 0.091: o resultado normalmente indica pouca ou nenhuma relação linear $(\beta _1 \approx 0)$. O R² mostra que o valor da conta não explica bem a variação percentual da gorjeta.

  No gráfico, os pontos ficam espalhados, sem uma tendência clara. A linha de regressão fica quase horizontal, indicando independência entre valor da conta e % da gorjeta.

Isso ocorre porque os dois modelos explicam algo diferente: o primeiro modelo mede quanto da variação no valor da gorjeta é explicada pela conta, enquanto o segundo mede quanto da variação no percentual da gorjeta é explicada pela conta. São escalas e unidades completamente distintas.
"""