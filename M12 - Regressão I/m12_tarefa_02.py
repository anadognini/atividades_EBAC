# -*- coding: utf-8 -*-
"""m12_tarefa_02

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19LeEmAVI9VmAMqcWcPPJu4F1vWIREDHP

### 1. Melhorando o ajuste no percentual de gorjetas

a. Vamos partir do modelo feito na última tarefa, o que relaciona ```tip_pct``` e ```net_bill```. Carregue a base, os pacotes e reproduza este modelo aqui.
"""

import pandas as pd
import seaborn as sns
from seaborn import load_dataset
import matplotlib.pyplot as plt
import numpy as np
import statsmodels.formula.api as smf

"""#### Modelo 1 - Original"""

tips = sns.load_dataset('tips')
tips['tip_pct'] = tips['tip'] / (tips['total_bill'] - tips['tip'])
tips['net_bill'] = tips['total_bill'] - tips['tip']
tips.head()

reg = smf.ols('tip_pct ~ net_bill', data=tips).fit()
reg.summary()

sns.regplot(y = 'tip_pct', x = 'net_bill', data=tips[tips['tip_pct'] < .5])

x = np.linspace(0, tips['net_bill'].max(), 100)
y = .1 * x

plt.plot(x, y, '-r', label='Linha dos 10%')
plt.xlim(left=0)
plt.ylim(bottom=0)

"""### 2. Ajuste o modelo de ```tip_pct``` em função do logaritmo de ```net_bill```.

#### Modelo 2 - Log de net_bill (variável explicativa)
"""

reg_log = smf.ols('tip_pct ~ np.log(net_bill)', data=tips).fit()
print(reg_log.summary())
tips['res_log'] = reg_log.resid

sns.scatterplot(x='net_bill', y='res_log', data=tips, alpha=.75)
plt.axhline(y=0, color='r', linestyle='--')

"""###  3. Ajuste o modelo de ```tip_pct``` em função de um polinômio de segundo grau em ```net_bill```.

#### Modelo 3 - Polinômio de net_bill (variável explicativa)
"""

reg_pol = smf.ols('tip_pct ~ net_bill + np.power(net_bill, 2)', data=tips).fit()
print(reg_pol.summary())
tips['res_pol'] = reg_pol.resid

sns.scatterplot(x='net_bill', y='res_pol', data=tips, alpha=.75)
plt.axhline(y=0, color='r', linestyle='--')

"""###  4. Ajuste um modelo no log do ```tip_pct``` em função de ```net_bill```. Calcule o $R^2$ também em ```tip_pct```

#### Modelo 4 - Log de tip_pct (variável resposta)
"""

reg_tip_log = smf.ols('np.log(tip_pct) ~ net_bill', data=tips).fit()
print(reg_tip_log.summary())
tips['res_tip_log'] = reg_tip_log.resid

sns.scatterplot(x='net_bill', y='res_tip_log', data=tips, alpha=.75)
plt.axhline(y=0, color='r', linestyle='--')

tips['pred_y'] = np.exp(reg_tip_log.fittedvalues)
r2 = tips[['pred_y', 'tip_pct']].corr().iloc[0, 1]
np.power(r2, 2)

"""###  5. Ajuste um modelo no log do ```tip_pct``` em função do log de ```net_bill```. Calcule o $R^2$ também em ```tip_pct```.

#### Modelo 5 - Log de tip_pct (variável resposta) e de net_bill (variável explicativa)
"""

reg_log_log = smf.ols('np.log(tip_pct) ~ np.log(net_bill)', data=tips).fit()
print(reg_log_log.summary())
tips['res_log_log'] = reg_log_log.resid

sns.scatterplot(x='net_bill', y='res_log_log', data=tips, alpha=.75)
plt.axhline(y=0, color='r', linestyle='--')

tips['pred_tip'] = np.exp(reg_log_log.fittedvalues)

r3 = tips[['pred_tip', 'tip_pct']].corr().iloc[0, 1]
np.power(r3, 2)

"""###  6. Qual modelo resultou no melhor ajuste?

O modelo 5 apresentou o maior R² na escala de ajuste e os resíduos mais bem distribuídos, ou seja, é o modelo que melhor representa a relação entre as variáveis.

Isso indica que a relação entre o valor da conta e o percentual da gorjeta é melhor representada por uma relação proporcional (em escala logarítmica) do que por uma relação linear direta.

É muito provável que os R² tenham dados resultados diferentes porque, ao aplicar np.exp() para voltar à escala original, a relação deixa de ser perfeitamente linear: o erro deixa de ser aditivo e passa a ser multiplicativo.
"""